一，关于python的一些基本知识

1.关于输入

1）只输入一个字符串

```python
s = input(“string”)
```

2）在python中输入进去的数据默认是字符串类型，于是当我们需要整数时可以利用int

```python
n = int(input())
```

3）多个整数

```python
a, b, c = map(int, input().split())
```

其中map函数接收一个函数，并根据提供的函数对指定的序列做映射。于是输入的string就变成了int类型的整数。

split函数通过指定分隔符对字符串进行切片，在（）中不填参数的话默认为所有的空字符，包括空格、换行(\n)、[制表符](https://so.csdn.net/so/search?q=制表符&spm=1001.2101.3001.7020)(\t)等。

而Python 的 strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。（注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。）

4）输入一个列表（在一行中）

```python
l = list(map(int, input().split()))
```

5）循环输入一个列表（多行）

```python
N = int(input())
l = [int(input()) for _ in range(N)]
```

6）列表中列表

```
N = int(input())
l = [list(map(int, input().split())) for _ in range(N)]
```

7）无终止条件的循环输入

```python
while True:
    try:
        
    except EOFError:
        break
```

2.关于输出

1）直接输出

```python
print(a, sep='', end='')
```

2）带join函数的输出

```python
a = [1, 2, 3, 4, 5]
print(''.join(map(str, a)))
```

3)格式化字符串

![image-20240523160045999](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523160045999.png)

![image-20240523160059911](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523160059911.png)

3.一些函数

1）运算符

![image-20240523151430870](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523151430870.png)

还有// 整除，返回整数部分；% 取模（取余数）。

2）

4.列表【】

列表是异构的，这意味着列表中的元素不一定是同一种类。列表是可修改的。

1）列表的一些操作

![image-20240523152004747](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523152004747.png)

注意【a：b】是左闭右开

2）关于列表的一些函数

![image-20240523152446217](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523152446217.png)

3）range

range(a, b, c)  的意思是从a到b（左闭右开），间隔为c。

5.字符串与元组（）

字符串和元组与列表不同的是字符串和元组是不可修改的。

1）字符串的函数

![image-20240523154009856](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523154009856.png)

6.集 {} 

集很像数学中的集合，它是无序的，且不可修改。

1）集中的运算与函数

![image-20240523155344062](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523155344062.png)

![image-20240523155409517](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523155409517.png)

7.字典 key：{}

字典是无序结构，由键：值的形式组成。可以通过键访问其对应的值，也可以向字典添加新的键–值对。

1）关于字典的运算以及函数

![image-20240523155656559](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523155656559.png)

二，算法分析

1.时间复杂度（大O）

Ox，x为问题规模中起决定性的部分。

下面是一些常见的大O函数

![image-20240523223843147](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523223843147.png)

2.列表

在生成列表的方法中，下面的方法是最省时间的

```python
l = list(range(1000))
```

以下是列表操作中的一些大O效率

![image-20240523231649705](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523231649705.png)

3.字典

下面是一些字典操作的大O效率

![image-20240523232424865](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240523232424865.png)

三，基本数据结构

例如栈，队列，双端队列和列表这种有序的数据集合，其元素的顺序取决于添加顺序或移除顺序，这样的数据集合经常被称为线性数据结构。

1.栈

栈有时也被称作“下推栈”。它是有序集合，添加操作和移除操作总发生在同一端，即“顶端”，另一端则被称为“底端”。栈中的元素离底端越近，代表其在栈中的时间越长，因此栈的底端具有非常重要的意义。最新添加的元素将被最先移除。这种排序原则被称作 LIFO(last-in first-out)，即后进先出。

我们可以用列表来实现栈。

1）括号匹配

括号匹配是关于栈的一种经典题型，匹配的左右括号出现的位置是倒序的，因此我们可以利用栈，遇到左括号则入栈，遇到右括号则弹出栈中的一个左括号，遍历完成后栈为空代表匹配正确。

多种括号也是如此，我们遇到右括号的时候不仅需要保证栈中存有左括号，并且栈顶括号类型需要与右括号匹配。

2）十进制数转n进制数

我们将十进制数转换为n进制数的方法是“除以n”算法，将给出的数反复除以n，获取其余数并压入栈中，最后将余数逐个弹出得到答案。

当n大于等于11时，我们需要借助字母来代表余数（A代表10，并以此类推）。

3）前序，后序，中序表达式

在日常生活中，我们所计算的式子运算符号大多都在数字之间，这种表达式叫做中序表达式。他根据运算符的优先级计算式子并得到答案。

通过改变运算符与操作数的相对位置，我们分别得到前序表达式和后序表达式。前序表达式要求所有的运算符出现在它所作用的两个操作数之前，后序表达式则相反。

在前序和后序表达式中运算顺序完全由运算符的位置决定。鉴于此，中序表达式是最不理想的算式表达法。于是我们需要将中序表达式转变为前序和后序表达式来进行计算。

我们可以将中序表达式转变为完全括号表达式，每一个括号中包含了一个小的中序表达式，其由两个数字和一个运算符组成。对于每一个小的中序表达式，我们可以将运算符放到右括号的位置得到后序表达式，将运算符放到左括号的位置得到前序表达式。

以下是一个从中序转变为后序的一个通用算法

![image-20240524135102097](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240524135102097.png)

```python
def f(s):
    prec = {}
    prec["*"] = 3
    prec["/"] = 3
    prec["+"] = 2
    prec["-"] = 2
    prec["("] = 1 #我们用一个字典来保存运算符的优先级来用于比较，“（”的优先级最小，保证运算符可以压进栈。
    stack = []
    res = []
    for i in s:
        if i not in '+-*/()':
            res.append(i)
        elif i == '(':
            stack.append(i)
        elif i == ')':
            j = stack.pop()
            while j != '(':
                res.append(j)
                j = stack.pop()
        else:
            while stack and prec[stack[-1]] >= prec[i]:
                res.append(stack.pop())
            stack.append(i)
    while stack:
        res.append(stack.pop())
    return res
```

将中序表达式转变为后序表达式后，我们需要求解后序表达式的值

```python
#小数改良版
def doMath(op, op1, op2):
    if op == '+':
        return op1 + op2
    elif op == '-':
        return op1 - op2
    elif op == '*':
        return op1 * op2
    else:
        return op1 / op2

def f(s):
    stack = []
    for i in s:
        if i in '+-*/':
            y = stack.pop()
            x = stack.pop()
            z = doMath(i, x, y)
            stack.append(z)
        elif float(i).is_integer():
            stack.append(int(i))
        elif i not in '+-*/':
            stack.append(float(i))
    return stack[0]
```

2.队列

队列是有序集合，添加操作发生在“尾部”，移除操作则发生在“头部”。新元素从尾部进入队列，然后一直向前移动到头部，直到成为下一个被移除的元素。 最新添加的元素必须在队列的尾部等待，在队列中时间最长的元素则排在最前面。这种排序原则被称作 FIFO(first-in first-out)，即先进先出，也称先到先得。

队列也可以用列表来实现。

1)传土豆问题（约瑟夫问题）

约瑟夫问题可以很好的用队列来实现，也非常直观，下面是主体代码

```python
while True:
    n, m = map(int, input().split())
    if n == 0 and m == 0:
        break
    else:
        queue = [i + 1 for i in range(n)]
        while len(queue) > 1:
            for _ in range(m - 1):
                x = queue.pop(0)
                queue.append(x)
            queue.pop(0)
        print(queue[0])
```

一开始从编号为p的孩子开始报数

```python
while True:
    n, p, m = map(int, input().split())
    if n == 0 and m == 0 and p == 0:
        break
    else:
        queue = [i + 1 for i in range(n)]
        res = []
        for _ in range(p - 1):
            x = queue.pop(0)
            queue.append(x)
        while queue:
            if len(queue) == 1:
                res.append(queue.pop(0))
            else:
                for _ in range(m - 1):
                    x = queue.pop(0)
                    queue.append(x)
                res.append(queue.pop(0))
        print(','.join(map(str, res)))
```

3.双端队列（deque）

双端队列是与队列类似的有序集合。它有一前、一后两端，元素在其中保持自己的位置。与队列不同的是，双端队列对在哪一端添加和移除元素没有任何限制。新元素既可以被添加到前端，也可以被添加到后端。同理，已有的元素也能从任意一端移除。某种意义上，双端队列是栈和队列的结合。

双端队列可以用来检查回文字符串。

4.链表

为了实现无序列表，我们要构建链表。无序列表需要维持元素之间的相对位置，但是并不需要在连续的内存空间中维护这些位置信息。

1）Node类

节点(node)是构建链表的基本数据结构。每一个节点对象都必须持有至少两份信息。首先，节点必须包含列表元素，我们称之为节点的数据变量。其次，节点必须保存指向下一个节点的引用。

节点十分重要，在关于树的部分十分常用，各个节点的连接组成了树。

![image-20240526131150040](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240526131150040.png)

四，递归

递归是解决问题的一种方法，它将问题不断地分成更小的子问题，直到子问题可以用普通的方法解决。通常情况下递归包含两部分，分别是终止条件和递推关系。

递归存在三种原则，分别是递归算法必须有基本情况，递归算法必须改变其状态并向基本情况靠近，递归算法必须递归地调用自己。

1.汉诺塔

2.走迷宫

3.动态规划

1）贪心算法

贪心算法试图在每一小部分都选择最优解来最大程度地解决问题，但有时候会得到错误的答案。

2）递归形式动态规划（记忆化）

在处理一般形式的题目，我们可以使用递归解决问题，但是在递归过程中可能会重复调用，从而大大增加复杂度。于是我们可以利用一个数组来存储已经得到的答案，来避免一些不必要的重复调用。

3）数组形式动态规划

数组形式动态规划通过多从循环填充数组的方式得到答案

五，搜索和排序

1.搜索

1）顺序搜索

存储于列表等集合中的数据项彼此存在线性或顺序的关系，每个数据项的位置与其他数据项相关。在 Python 列表中，数据项的位置就是它的下标。因为下标是有序的，所以能够顺序访问，由此可以进行顺序搜索。

顺序搜索的时间复杂度是O(n)，但是有序列表的顺序搜索可以进行一些剪枝。

2）二分搜索

二分搜索是进行在有序列表中的，我们反复找部分序列的中间值进行判断，最终得到答案，二分搜索的时间复杂度是O(logn)，

3）散列表

散列表本质上是一个列表，下标代表索引，对应一个可以存放元素的槽，我们通过散列函数得到一个数值，并将该元素存到数值所对应的下标中，这样我们搜索的时间复杂度就达到了O(1)，

在构造散列函数的时候，我们希望每个元素都能映射到不同的槽，散列函数称作完美散列函数。完美散列函数很难实现，但是不完美的散列函数也有不错的性能，不过我们要处理冲突。

当两个元素被分到同一个槽中时，必须通过一种系统化方法在散列表中安置第二个元素。这个过程被称为处理冲突。

字典与散列表相似，是一种强大的集合

2.排序

1）冒泡排序

冒泡排序的函数大致如下

![image-20240528115137086](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240528115137086.png)

冒泡排序的时间复杂度是O(n^2)，但是我们可以对冒泡排序算法进行改进，由于在列表有序的情况下元素并不会进行交换，于是我们可以判断是否可以提前终止排序，这种冒泡叫做短冒泡。

![image-20240528115542282](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240528115542282.png)

2）选择排序

选择排序是对冒泡排序的一种改进，在每一层循环中它都寻找最大值，并在最后把它放到正确的位置上，这样在每一层循环中都只交换一次

![image-20240528115959166](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240528115959166.png)

选择排序的时间复杂度也是O(n^2)，但是它往往比冒泡排序快一些。

3）插入排序

插入排序的时间复杂度也是 O(n^2 ) 但原理稍有不同。它在列表较低的一端维护一个有序的子列表，并逐个将每个新元素“插入”这个子列表。

![image-20240528120356245](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240528120356245.png)

移动操作和交换操作有一个重要的不同点。总体来说，交换操作的处理时间大约是移动操作的3倍，因为后者只需进行一次赋值。在基准测试中，插入排序算法的性能很不错。

4）希尔排序

5）归并排序

![image-20240528122031913](/Users/xiaosi/Library/Application Support/typora-user-images/image-20240528122031913.png)

6）快速排序

六，树

1.树的相关概念

1）树是n(n≥0)个结点的有限集。当n=0时，称为空树。在任意一棵非空树中应满足：有且仅有一个特定的结点称为根的结点；当n>1时,其余结点可分为m（m>0）个互不相交的有限集T1,T2,…,Tm,其中每个集合本身又是一棵树,并且称为根的子树。树具有以下两个特点：树的根结点没有前驱，除根结点外所有结点有且只有一个前驱；树中所有结点可以有零个或多个后继。故**n个结点的树中有n-1条边。**

2）考虑结点N,根R到结点N的唯一路径上的任意结点,称为结点N的**祖先**。如结点R就是结点N的祖先,而结点N是结点R的**子孙；**路径上最接近结点N的结点P(也即N的唯一前驱)称为N的**双亲,**而N为结点P的**孩子；根R是树中唯一没有双亲的结点；**有相同双亲的结点称为**兄弟。**

3）树中一个结点的孩子个数称为该**结点的度,**树中结点的最大度数称为**树的度；**度为0(没有子女结点)的结点称为**叶子结点。**

4）结点的层次从树根开始定义,根结点为第1层,它的子结点为第2层,以此类推；双亲在同一层的结点互为堂兄弟；树的深度**是树中结点的最大层数，**树的高度通常是树的深度减1(关于树的高度和深度的定义，不同地方有不同解释，需具体情况具体分析)

5）森林是m (m>0)棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树。

2.树的性质

1）树中的结点数等于所有结点的度数加1;(度对应子结点，而根结点不是任何一个结点的子节点)

2）度为m的树中第i层上至多有m^(i-1)个结点(i≥1)

3）深度为h的m叉树至多有(m^h-1)/(m-1)个结点

4）具有n个结点的m叉树的最小高度为[log m(n(m-1)+1)]

3.树的存储结构

1）双亲表示法

以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。

2）孩子表示法

将每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

```python
class Node:
def __init__(self,val):
  self.val=val
  self.first_child=None
class ChildNode:
def __init__(self):
  self.index=-1
  self.next_sibling=None
```

3）孩子(右)兄弟表示法

又称为二叉树表示法，包括三部分：结点值、指向结点第一个孩子结点的指针、指向结点下一个兄弟结点的指针。也常用该方法将一棵树转化为二叉树。

4）二叉树的相关概念

二叉树是另一种树形结构，其特点是每个结点至多只有左、右两棵子树(即二叉树中不存在度大于2的结点)；

二叉树是有序树，即互换左右子树会得到另一棵不同的二叉树，即使树中结点只有一棵子树，也需区分它是左子树还是右子树。

斜树：所有结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。二者统称为斜树。

满二叉树：深度为h且含有2^h-1个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。满二叉树的叶子结点都在二叉树的最后一层，且除叶子结点之外每个结点的度数均为2。若对满二叉树从上至下、从左至右编号，则对于编号为i的结点，若有双亲，其双亲的编号为i//2；若有左孩子，其左孩子的编号为2*i;若有右孩子，其右孩子的编号为2*i+1。

完全二叉树：深度为h且有n个结点的二叉树，若按上述方式编号后每个结点的编号与深度为h的满二叉树中编号为1~n的结点一一对应时，成为完全二叉树。其特点如下：若i≤n//2，则结点i为双亲节点，否则为叶子结点；叶子结点只可能在层次最大的两层上出现，最大层次中的叶子结点都在该层的最左边，次大层次中的叶子结点都在该层的最右边；若有度为1的结点，则只能有一个，且该结点有左孩子而没有右孩子；若编号为i的结点只有左孩子或者是叶子结点，则编号大于i的结点全是叶子结点；若n为奇数，则每个双亲结点都有左孩子和右孩子;若n为偶数，则编号最大的双亲结点(编号为n/2)只有左孩子，没有右孩子，其余双亲结点左、右孩子都有。

5）二叉树的性质

具有树的所有性质；

非空二叉树上的叶子结点数等于度为2的结点数加1 (n_0+n_1+n_2=2*n_2+n_1+1,即n_0=n_2+1)

6）二叉树的存储结构

顺序存储：适用于满/完全二叉树，一般二叉树需补全空结点

链式存储：与(三)中类似

7）二叉树的遍历

先序遍历

访问根结点→先序遍历左子树→先序遍历右子树

中序遍历

中序遍历左子树→访问根结点→中序遍历右子树

后序遍历

后序遍历左子树→后序遍历右子树→访问根结点

层次遍历

按照从上到下的层次顺序，从左到右的结点顺序进行遍历

根据前中遍历序列得后序遍历序列

前序遍历序列的第一个一定是根结点，然后利用中序遍历序列可得到左右子树的中序遍历序列，进而得到左右子树的前序遍历序列，左右子树的前序遍历序列的第一个又是它们的根结点，如此递归下去即可。

根据中后遍历序列得前序遍历序列

与5类似，只是改成后序遍历序列的最后一个一定是根结点。

注：无法根据前后遍历序列得到中序遍历序列，因为只能得到根结点的信息

8）（二叉）树的应用

二叉搜索树/二叉查找树/二叉排序树(BST)

指满足以下性质的二叉树：若左子树非空，则左子树上所有结点的值均不大于它的根结点的值；若右子树非空，则右子树上所有结点的值不小于它的根结点的值；左右子树也分别为BST。

二叉树中的删除操作：

(1)如果待删除的结点是叶子结点，那么可以立即被删除；

(2)如果结点只有一个儿子，则将此结点的parent的孩子指针指向此结点的孩子，然后删除节点；

(3)如果结点有两个儿子，则将其右子树的最小数据代替此结点的数据，并将其右子树的最小数据删除。

平衡二叉树(AVL)

一种特殊的BST，每个结点应满足左子树与右子树高度差的绝对值不大于1。将二叉树上结点的左子树高度减去右子树高度的值称为结点的平衡因子(Blance Factor)，则平衡二叉树上所有结点的平衡因子只能为±1，0。

平衡二叉树插入结点导致失衡时恢复平衡的操作：

LL型失衡(导致失衡的插入结点位于被破坏结点左孩子的左子树中)

将被破坏结点A的左孩子B作为新根，将A作为B的右孩子，若B已有右孩子C，则将C作为A的左孩子。这个过程称为右旋；

RR型失衡(导致失衡的插入结点位于被破坏结点右孩子的右子树中)

将被破坏结点A的右孩子B作为新根，将A作为B的左孩子，若B已有左孩子C，则将C作为A的右孩子。这个过程称为左旋；

LR型失衡(导致失衡的结点位于被破坏节点的左孩子的右子树中)

以被破坏节点的左孩子为基础进行一次左旋，再以被破坏结点为基础进行一次右旋；

RL型失衡(导致失衡的结点位于被破坏节点的右孩子的左子树中)

以被破坏节点的右孩子为基础进行一次右旋，再以被破坏结点为基础进行一次左旋。

平衡二叉树删除节点导致失衡时恢复平衡的操作：

**(1)****删除右子树的结点且被破坏结点的左孩子的左子树高度大于或等于右子树

相当于LL型失衡，右旋即可。

**(2)****删除右子树的结点且被破坏结点的左孩子的左子树高度小于右子树

相当于LR型失衡，以左孩子为基础左旋后再以被破坏结点为基础右旋即可。

**(3)****删除左子树的结点且被破坏节点的右孩子的右子树高度大于或等于左子树

相当于RR型失衡，左旋即可。

**(2)****删除左子树的结点且被破坏结点的右孩子的右子树高度小于左子树

相当于RL型失衡，以右孩子为基础右旋后再以被破坏结点为基础左旋即可。

**3.Huffman****树与Huffman编码：**

在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。该结点到根的路径长度(经过的边数)与它的权值的乘积称为**该结点的带权路径长度。**树中所有叶子结点的带权路径长度之和称为**该树的带权路径长度（WPL）。**在含有n个带权叶子结点的二叉树中，WPL最小的二叉树**称为Huffman树，也称最优二叉树。**它的构造步骤如下：

(1)先把n个带权叶子结点按权值大小排序成一个有序序列；

(2)取权值最小的两个结点作为一个新结点的两个子结点，左孩子的权值相对较小；

(3)把两个子结点的权值和赋给新结点，将其插入(1)中的有序序列，并保持大小顺序；

(4)重复步骤(2)(3)直到出现根结点。

Huffman编码是一种将字母串转化为二进制字符串的编码方式，把每个字母作为一个叶子结点，它的权是在字母串中出现的频率，按照上述步骤构造Huffman树后，从根到叶子结点按左0右1的方式对字母进行编码，这样得到的二进制字符串的平均长度最短。

**5.****并查集：**

并查集是一种树型的数据结构，用于处理一些不相交集合的相关问题，有如下两个基本操作：

(1)查询：查询元素所属的集合，通常使用一个结点来代表整个集合，即一个元素的根结点/集合的代表元

(2)合并：将两个代表元不同的集合进行合并，并更新合并后集合的代表元。

**六、图：**

**(****一)图的相关概念：**

1.图由顶点的有穷非空集合和顶点之间的边的集合组成，通常表示为G(V,E)，其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

2.一个图G若满足：不存在重复的边、顶点到自身的边，则称图G为简单图。数据结构中仅讨论简单图。

3.设有两个图G=(V,E)和G′=(V′,E′),若V′是V的子集，E′是E的子集，则称G′是G的子图。

4.在一个图中，每条边都可以标上具有某种含义的数值，称为该边的**权值**。边上带有权值的图称为**带权图，**也称**网。**

5.若E是无向边(简称边)的有限集合，则图G是**无向图**。边是顶点的无序对，记为(v,w)或(w,v)，其中v,w是顶点,因为(v,w)=(w,v)，所以它们表示同一条边。

6.若E是有向边(也称弧)的有限集合，则图G为**有向图**。弧是顶点的有序对，记为<v,w>，其中v,w是顶点，v称为弧尾，w称为弧头，注意<v,w>≠<w,v>。

7.有n个顶点、n(n-1)/2条边的无向图称为**完全图**，即任意两个顶点之间都存在边；有n个顶点、n(n-1)条弧的有向图称为**有向完全图，**在有向完全图中任意两个顶点之间都存在方向相反的两条弧。

8.边数很少的图称为**稀疏图**，反之称为**稠密图**。一般认为图G满足|E|<|V|log|V|时，可将其视为稀疏图。

9.图中每个顶点的**度**定义为以该顶点为一个端点的边的数目，记为TD(v)。对于无向图，全部顶点的度等于边数的2倍。对于有向图，顶点的度分为**入度**和**出度，**入度是以顶点为终点的有向边的数目，记为ID(V)；出度是以顶点为起点的有向边的数目，记为OD(v)；顶点的度等于其入度和出度之和，即TD(v)=ID(v)+OD(v)。

10.顶点vp到顶点vq之间的一条**路径**是指顶点序列vp，v1，v2，…，vm，vq，关联的边可理解为路径的构成要素。路径上边的数目称为**路径长度，**顶点vp到顶点vq路径长度的最小值称为它们之间的距离。第一个顶点和最后一个顶点相同的路径称为**环。**若一个无向图有n个顶点和大于n-1条边，则此图一定有环。

11.在无向图中，若从顶点v到顶点w有路径存在，则称v和w是**连通**的，若图G中任意两个顶点都是连通的，则称图G为**连通图，**否则称为**非连通图。**无向图中的极大连通子图称为**连通分量。**

12.在有向图中，若从顶点v到顶点w和顶点w到顶点v之间都有路径，则称v和w是**强连通**的。若图G中任意两个顶点之间都是强连通的，则称图G为**强连通图**。有向图中的极大强连通子图称为**强连通分量。**

13.连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成树含有n-1条边。对于生成树，删去其任一条边，都会变成非连通图。

**(****二)图的存储结构：**

**1.****邻接矩阵：**

用一个矩阵储存图中的边或弧的信息，设图G有n个顶点，则邻接矩阵A是一个n级方阵，若顶点vi与顶点vj之间有边/弧，则A[i][j]=1,否则为0。无向图的邻接矩阵一定是个主对角元全为0的对称矩阵，每个顶点的度就是顶点对应的行或列的非零元素个数；有向图的邻接矩阵主对角元全为0，但不一定是对称矩阵，每个顶点的入度是顶点对应的列的非零元素个数，出度是对应的行的非零元素个数。对于带权图，若顶点vi与顶点vj之间有边/弧，则A[i][j]=该边/弧的权值，若顶点vi与顶点vj是同一个顶点，则A[i][j]=0，若顶点vi与顶点vj之间没有边/弧，则A[i][j]=∞。

**2.****邻接表&逆邻接表：**

若一个图为稀疏图，使用邻接矩阵会浪费存储空间，此时用邻接表存储更合适。邻接表是指对图G的每个顶点建立一个单链表，第i个单链表中的顶点表示依附于顶点vi的边(对于有向图则是以顶点vi为尾的弧)，这个单链表就称为顶点vi的边表(对于有向图则称为出边表)。边表的头指针和顶点的数据采用顺序存储(称为顶点表)

逆邻接表用于存储有向图，与邻接表的不同只是改为第i个单链表中的顶点表示以顶点vi为头的弧，得到顶点vi的入边表。

**(****三)图的遍历：**

**1.****深度优先遍历(DFS):**

**(1)****算法简介：**

DFS是一种系统地访问图中所有顶点的算法。它起始于一个初始顶点，然后沿着一条路径持续走到尽可能深的顶点，直至到达一个没有未访问邻接顶点的顶点为止，然后回溯并继续访问其他分支。基本步骤：

①选择一个起始顶点，将其标记为已访问。

②访问与起始顶点之间有边的顶点，根据要求处理当前节点。

③递归地对当前节点的所有未访问邻接节点进行深度优先遍历或者用栈来模拟递归的过程，将当前节点的所有未访问邻接节点压入栈中，然后从栈顶节点开始继续遍历。

**(3)****应用：**

①连通性问题，如最大连通域面积

②棋盘问题，如八皇后，骑士周游(优化：Warnsdoff's rule，每次访问具有最少未访问邻居的顶点)

**2.****广度优先遍历(BFS):**

**(1)****算法简介：**

与DFS不同，BFS从一个起始顶点开始，访问完当前顶点的所有邻接点之后，再访问下一层的所有顶点，整个过程需要维护队列。基本步骤：

①选择一个起始顶点，将其标记为已访问并放入队列。

②从队列中取出一个节点，根据要求处理当前节点后访问所有与之相邻且未被访问的节点，将这些节点标记为已访问并加入队列。

③重复以上步骤直到队列为空。

**(3)****应用：**求解最短路径

**(****四)带权图的最短路径(指边上的权值和最小)问题:**

**1.Dijkstra****算法：**

从起始顶点开始，采用贪心算法的策略，每次访问与当前顶点之间的边的权值最小且未被访问的邻接顶点，直至扩展到终点位置。可用于有向图，但是不能存在负权值。

**2.Floyd****算法：**

定义一个n阶方阵序列A0，A1，…，An-1。其中A0是图G的邻接矩阵，Ak[i][j]=min{Ak-1[i][j],Ak-1[i][k]+Ak-1[k][j]}。这是一个递归迭代的过程，经过n次迭代后得到的An-1[i][j]就是vi到vj的最短路径长度。可用于带负权值的图但不能有环。

**(****五)判断图是否连通&有环：**

**1.****判断连通：**

若DFS/BFS可以访问到所有顶点点，或者并查集进行合并后所有顶点的祖先是同一个，则说明连通。

**2.****无向图判环：**

若DFS/BFS访问某顶点的邻接点时显示该邻接点已被访问且不是当前顶点的父顶点，或者并查集进行合并过程中发现两个顶点在合并之前已经属于同一个集合，则说明有环。

**3.****有向图判环：**

若DFS过程中有顶点被第二次访问到，则说明有环。也可用拓扑排序(见下文)

**4.****拓扑排序：**

**(1)****相关概念：**

在一个表示工程的有向无环图(DAG)中，用顶点表示活动，用弧表示活动之间的优先关系，即<v，w>表示活动v必须先于活动w，把v称为w的直接前驱，w称为v的直接后继。这样的有向无环图称为AOV网(Activity On VertexNetwork)。

设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v1，v2，…，vm，若满足每一个顶点都是它前一个顶点的直接后继，后一个顶点的直接前驱，则称为一个拓扑序列。拓扑排序就是对一个有向图构造拓扑序列的过程。

**(2)****算法步骤：**

①从AOV网中选择一个没有前驱的顶点，也即入度为0的顶点并输出；

②从网中删除该顶点和所有以它为尾的弧；

③重复上述操作直至AOV网为空或者当前网中不存在没有前驱的顶点为止。**若输出的顶点数少于初始AOV网的顶点数，则说明有环。**

**(****六)最小生成树(MST)：**

对于一个带权无向图，边的权值和最小的那棵生成树称为G的最小生成树。

**1.Prim****算法：**

建立最小生成树时，将顶点按是否已包含在树中分为A,B两类。初始状态所有点都属于B类，然后任取一个点作为起始点，将它移至A类，在B类中查找与起始点相连且权值最小的点，再将该点移至A类。每次都从B类中查找与A类中的点相连且权值最小的点直到B类为空为止。

**2.Kruskal****算法：**

将所有权值按升序排列，每次对最小权值进行判断，如果不形成环就添加；否则不添加。是否形成环要用到并查集。
